# Digital Identity Verification Flow

This document provides a comprehensive explanation of the verification flow in the Blockchain Identity System, focusing on the multi-verifier security feature that requires at least 2 different verifiers to upgrade an identity to KYC_VERIFIED level or higher.

## Verification Levels

The system supports four verification levels:

1. **UNVERIFIED (0)** - Initial state when an identity is first created
2. **BASIC_VERIFIED (1)** - Basic verification completed, requires 1 verifier approval
3. **KYC_VERIFIED (2)** - KYC verification complete, requires 2 different verifier approvals
4. **FULL_VERIFIED (3)** - Enhanced verification, requires 2 different verifier approvals with additional checks

## Multi-Verifier Security Feature

A key security feature of the DigitalIdentityNFT contract is the requirement for **at least 2 different verifier addresses** to approve before upgrading an identity to KYC_VERIFIED (level 2) or higher. This security mechanism prevents a single compromised verifier from granting high verification levels.

## Components Involved in Verification

### Smart Contracts
1. **VerificationRegistry.sol** - Handles verification requests and maintains a registry of verification claims
2. **DigitalIdentityNFT.sol** - Manages identity tokens and their verification levels

### Services
1. **Oracle Service** - Off-chain service that processes verification requests and interacts with the blockchain
2. **KYC Providers** - External or mock services that perform actual KYC verification

## API Endpoints Overview

### Backend API (localhost:3000)
- `/api/system/health` - Check backend API health status
- `/api/identity/{address}` - Get identity information for a specific address
- `/api/identity/create` - Create a new identity
- `/api/identity/verificationLevel` - Get verification level for an address

### Oracle API (localhost:3030)
- `/health` - Check Oracle API health status
- `/api/identity/verificationLevel` - Get verification level for an address
- `/api/verifications/mock` - Submit a mock verification request
- `/api/verifications/pending` - List any pending verifications
- `/api/verifications/second-approval` - Request a second verifier approval

## Detailed Verification Flow

### 1. Authentication

Before creating an identity, you must authenticate with the system using your Ethereum wallet address and a signed message:

```javascript
// First, authenticate to get JWT token using admin wallet
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "address": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "signature": "0xbdc93f9366702679fc1034a55755d43ca316e07771a483ae18180e38beb29e03102ac67b87524df9f0c621ffaa60f0074209587bb13c0db5bdcd837ccfbbdb301c",
    "timestamp": "1744747628"
  }'
```

Note: The signature above is generated by signing the message `Authenticate to Identity System: 1744747628` with the admin wallet's private key (`0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80`). In a real application, you would use a current timestamp and generate the signature dynamically.

The response will include an access token that you'll use for subsequent API calls:

```json
{
  "success": true,
  "data": {
    "accessToken": "eyJhbGciOiJIU...",
    "refreshToken": "eyJhbGciOiJIU..."
  }
}
```

### 2. Identity Creation

An identity is created in the DigitalIdentityNFT contract via the Backend API. Initially, the identity has a verification level of 0 (UNVERIFIED).

```javascript
// Create identity through Backend API (requires authentication)
curl -X POST http://localhost:3000/api/identity/create \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -d '{
    "userAddress": "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
    "did": "did:ethr:0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
    "metadata": {
      "name": "Test User",
      "email": "user@example.com",
      "createdAt": "2023-04-15T10:30:00Z"
    }
  }'
```

### 3. Request Verification

A user requests verification through the Oracle's mock verification endpoint (for testing) or through the standard verification request endpoint:

```javascript
// Request mock verification through Oracle API
curl -X POST http://localhost:3030/api/verifications/mock \
  -H "Content-Type: application/json" \
  -d '{
    "address": "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
    "verificationType": 0,
    "metadata": {
      "fullName": "Test User",
      "dateOfBirth": "1990-01-01",
      "documentType": "passport",
      "documentId": "AB123456",
      "nationality": "USA",
      "verificationRequest": "2023-04-15T10:30:00Z"
    }
  }'
```

The Oracle service processes this request and performs two steps:
1. Uses the `verify` method in VerificationRegistry to mark the verification as confirmed
2. Approves the verification in DigitalIdentityNFT to level 1 (BASIC_VERIFIED)

### 4. Oracle Processes Verification

When processing the verification, the Oracle:

1. Utilizes its VERIFIER_ROLE to directly call the verification contract
2. Processes the verification data (either through a mock or external KYC provider)
3. Submits the verification result to the VerificationRegistry using the `verify` method
4. Computes a unique verification ID based on the user address and verification type
5. Retrieves the token ID for the user's address
6. Approves the verification in the DigitalIdentityNFT contract to BASIC_VERIFIED level

```javascript
// Oracle confirms verification in VerificationRegistry and approves in DigitalIdentityNFT
const verifyResult = await blockchainService.executeTransaction(
  'verification',
  'verify',
  [
    address,  // The address to verify
    verificationTypeNum,
    metadataStr,
    "0x" // Empty signature
  ]
);

// Then approves in DigitalIdentityNFT
const approveResult = await blockchainService.executeTransaction(
  'identity',
  'approveVerification',
  [tokenId, 1] // Level 1 = BASIC_VERIFIED
);
```

### 5. Check for Pending Verifications (Optional)

After submitting a verification request, you can check if there are any pending verifications:

```javascript
// Check pending verifications
curl http://localhost:3030/api/verifications/pending
```

With the current implementation, verifications are processed immediately, so this step typically returns an empty list.

### 6. Second Verifier Approval in DigitalIdentityNFT

To upgrade to KYC_VERIFIED level, a second verifier must approve:

```javascript
// Request second verifier approval through Oracle API
curl -X POST http://localhost:3030/api/verifications/second-approval \
  -H "Content-Type: application/json" \
  -d '{
    "tokenId": "1",
    "targetLevel": 2
  }'
```

The Oracle service handles this by using a different verifier wallet to make the approval:

1. It creates a new ethers.js wallet with a different private key (Account #2 in Hardhat)
2. Ensures this second wallet has the VERIFIER_ROLE in the DigitalIdentityNFT contract
3. Creates a contract instance with the second verifier as signer
4. Calls `approveVerification` directly through this contract instance:

```javascript
// Create a wallet for the second verifier
secondVerifierWallet = new ethers.Wallet(secondVerifierPrivateKey, provider);

// Create contract instance with second verifier as signer
identityContractWithSecondVerifier = new ethers.Contract(
  identityContractAddress,
  identityContractABI,
  secondVerifierWallet
);

// Approve verification as second verifier
tx = await identityContractWithSecondVerifier.approveVerification(
  tokenId,
  verificationLevel // 2 = KYC_VERIFIED
);
```

The second verifier **must be a different address** than the first verifier.

### 7. Check Verification Level

After both verifier approvals, the identity should have a verification level of 2 (KYC_VERIFIED). You can check this through the Oracle API:

```javascript
// Check verification level through Oracle API
curl http://localhost:3030/api/identity/verificationLevel?address=0x70997970C51812dc3A010C7d01b50e0d17dc79C8
```

The response includes both the numeric level and the name:

```json
{
  "success": true,
  "data": {
    "level": 2,
    "levelName": "KYC VERIFIED",
    "address": "0x70997970C51812dc3A010C7d01b50e0d17dc79C8"
  }
}
```

## Role Requirements

Both verifiers must have the VERIFIER_ROLE in both contracts:

```javascript
// For DigitalIdentityNFT
const verifierRole = await identityContract.VERIFIER_ROLE();
await identityContract.grantRole(verifierRole, verifierAddress);

// For VerificationRegistry
await verificationContract.grantRole(verifierRole, verifierAddress);
```

## Testing the Flow

### Using the API Flow Script

The repository includes a script to test the full verification flow:

```bash
# From project root
./scripts/test-api-flow.sh
```

This script demonstrates the complete verification flow:
1. Checks health of both Backend and Oracle services
2. Authenticates with the Backend API to get a JWT token
3. Creates an identity using the Backend API with proper authorization
4. Checks initial verification level
5. Requests verification through the Oracle service's mock verification endpoint
6. Checks for any pending verifications
7. Verifies the verification level has been updated to BASIC_VERIFIED
8. Adds a second verifier approval through the Oracle service
9. Checks the final verification level to confirm it has been upgraded to KYC_VERIFIED

The script includes detailed error handling and diagnostic information to help troubleshoot any issues during the verification process.

### Manual Testing with Oracle API

You can also manually test the verification flow using API requests to the Oracle service:

```bash
# 1. Authenticate to get a token
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "address": "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
    "signature": "0xYOUR_ETHEREUM_SIGNATURE_HERE",
    "timestamp": "1683564789"
  }'

# Store the access token from the response
ACCESS_TOKEN="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."

# 2. Create identity with the token
curl -X POST http://localhost:3000/api/identity/create \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer ${ACCESS_TOKEN}" \
  -d '{
    "userAddress": "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
    "did": "did:ethr:0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
    "metadata": {
      "name": "Test User",
      "email": "user@example.com"
    }
  }'

# 3. Request verification through Oracle API
curl -X POST http://localhost:3030/api/verifications/mock \
  -H "Content-Type: application/json" \
  -d '{
    "address": "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
    "verificationType": 0,
    "metadata": {
      "fullName": "Test User",
      "dateOfBirth": "1990-01-01",
      "documentType": "passport",
      "documentId": "AB123456",
      "nationality": "USA"
    }
  }'

# 4. Get token ID from identity
curl http://localhost:3030/api/identity/verificationLevel?address=0x70997970C51812dc3A010C7d01b50e0d17dc79C8

# 5. Add second verifier approval
curl -X POST http://localhost:3030/api/verifications/second-approval \
  -H "Content-Type: application/json" \
  -d '{
    "tokenId": "1",
    "targetLevel": 2
  }'

# 6. Check final verification level
curl http://localhost:3030/api/identity/verificationLevel?address=0x70997970C51812dc3A010C7d01b50e0d17dc79C8
```

This manual process follows the same steps as the automatic script but allows you to inspect the responses at each stage.

## Debugging Common Issues

### Verification Level Stuck at BASIC_VERIFIED

If the verification level remains at 1 (BASIC_VERIFIED) after the KYC process:

1. **Check verifier roles**: Ensure the second verifier has VERIFIER_ROLE in the DigitalIdentityNFT contract
2. **Check verification count**: Use `identityContract.verificationCount(tokenId)` to see how many verifiers have approved
3. **Using same verifier**: Confirm you're using two different verifier addresses for the approvals
4. **Role assignment**: Check role assignments with `identityContract.hasRole(verifierRole, verifierAddress)`

### Transaction Failures

- "Requires multiple verifier approvals" - This error occurs when trying to upgrade to KYC_VERIFIED without having 2 different verifiers
- "Caller doesn't have VERIFIER_ROLE" - The account needs to be granted the VERIFIER_ROLE
- "Transaction from mismatch" - The wrong account is being used to send the transaction

### API Response Field Variations

In some cases, the API response field names may vary between services:
- `level` vs `verificationLevel`
- `levelName` vs `verificationLevelName`

The test script handles these variations automatically.

### BigInt Serialization Errors

When working with the API, you might encounter BigInt serialization errors in the JSON response. The Oracle service now includes proper handling for BigInt values with a custom serialization function:

```javascript
// Helper function to safely stringify BigInt values
const safeStringify = (obj) => {
  return JSON.stringify(obj, (key, value) => 
    typeof value === 'bigint' ? value.toString() : value
  );
};

// Parse and re-stringify to handle any nested BigInt values
return res.json(JSON.parse(safeStringify(responseObj)));
```

## Advanced Usage

### Upgrading to FULL_VERIFIED Level

To upgrade to level 3 (FULL_VERIFIED), similar steps are required but with a higher level:

```javascript
// First approval (if not already done)
await identityContract.connect(firstVerifier).approveVerification(tokenId, 1);

// Second verifier approves to FULL_VERIFIED level
await identityContract.connect(secondVerifier).approveVerification(tokenId, 3);
```

### Verification Expiration

Verifications in the VerificationRegistry have an expiration date:

```javascript
// Set expiration to 1 year from now
const expirationTime = Math.floor(Date.now() / 1000) + 31536000;
await verificationContract.confirmVerification(verificationId, true, resultMetadata, expirationTime);
```

When a verification expires, the identity will maintain its verification level until explicitly downgraded or re-verified.